// Code generated by protoc-gen-go.
// source: validator.proto
// DO NOT EDIT!

/*
Package amp_validator is a generated protocol buffer package.

It is generated from these files:
	validator.proto

It has these top-level messages:
	AttrTriggerSpec
	PropertySpec
	PropertySpecList
	UrlSpec
	AttrSpec
	AttrList
	BlackListedCDataRegex
	AtRuleSpec
	CssSpec
	CdataSpec
	AmpLayout
	ChildTagSpec
	ReferencePoint
	ExtensionSpec
	TagSpec
	ValidatorRules
	ErrorCategory
	ValidationError
	ErrorSpecificity
	ErrorFormat
	ValidationResult
	ValidatorInfo
*/
package amppb

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type AtRuleSpec_BlockType int32

const (
	// Invalid, ignore contents.
	AtRuleSpec_PARSE_AS_ERROR AtRuleSpec_BlockType = 0
	// Valid, ignore contents.
	AtRuleSpec_PARSE_AS_IGNORE AtRuleSpec_BlockType = 1
	// Valid, parse contents (as CSS rules).
	AtRuleSpec_PARSE_AS_RULES AtRuleSpec_BlockType = 2
	// Valid, parse contents (as CSS declarations).
	AtRuleSpec_PARSE_AS_DECLARATIONS AtRuleSpec_BlockType = 3
)

var AtRuleSpec_BlockType_name = map[int32]string{
	0: "PARSE_AS_ERROR",
	1: "PARSE_AS_IGNORE",
	2: "PARSE_AS_RULES",
	3: "PARSE_AS_DECLARATIONS",
}
var AtRuleSpec_BlockType_value = map[string]int32{
	"PARSE_AS_ERROR":        0,
	"PARSE_AS_IGNORE":       1,
	"PARSE_AS_RULES":        2,
	"PARSE_AS_DECLARATIONS": 3,
}

func (x AtRuleSpec_BlockType) Enum() *AtRuleSpec_BlockType {
	p := new(AtRuleSpec_BlockType)
	*p = x
	return p
}
func (x AtRuleSpec_BlockType) String() string {
	return proto.EnumName(AtRuleSpec_BlockType_name, int32(x))
}
func (x *AtRuleSpec_BlockType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AtRuleSpec_BlockType_value, data, "AtRuleSpec_BlockType")
	if err != nil {
		return err
	}
	*x = AtRuleSpec_BlockType(value)
	return nil
}

type AmpLayout_Layout int32

const (
	AmpLayout_UNKNOWN      AmpLayout_Layout = 0
	AmpLayout_NODISPLAY    AmpLayout_Layout = 1
	AmpLayout_FIXED        AmpLayout_Layout = 2
	AmpLayout_FIXED_HEIGHT AmpLayout_Layout = 3
	AmpLayout_RESPONSIVE   AmpLayout_Layout = 4
	AmpLayout_CONTAINER    AmpLayout_Layout = 5
	AmpLayout_FILL         AmpLayout_Layout = 6
	AmpLayout_FLEX_ITEM    AmpLayout_Layout = 7
)

var AmpLayout_Layout_name = map[int32]string{
	0: "UNKNOWN",
	1: "NODISPLAY",
	2: "FIXED",
	3: "FIXED_HEIGHT",
	4: "RESPONSIVE",
	5: "CONTAINER",
	6: "FILL",
	7: "FLEX_ITEM",
}
var AmpLayout_Layout_value = map[string]int32{
	"UNKNOWN":      0,
	"NODISPLAY":    1,
	"FIXED":        2,
	"FIXED_HEIGHT": 3,
	"RESPONSIVE":   4,
	"CONTAINER":    5,
	"FILL":         6,
	"FLEX_ITEM":    7,
}

func (x AmpLayout_Layout) Enum() *AmpLayout_Layout {
	p := new(AmpLayout_Layout)
	*p = x
	return p
}
func (x AmpLayout_Layout) String() string {
	return proto.EnumName(AmpLayout_Layout_name, int32(x))
}
func (x *AmpLayout_Layout) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AmpLayout_Layout_value, data, "AmpLayout_Layout")
	if err != nil {
		return err
	}
	*x = AmpLayout_Layout(value)
	return nil
}

// The HtmlFormat field tells the validator which html formats
// (ie: (<html ⚡> vs <html a4⚡>) this HTML TagSpec is relevant for.)
// If the repeated field is empty, this indicates that the TagSpec is allowed
// for all formats, rather than none.
type TagSpec_HtmlFormat int32

const (
	TagSpec_AMP     TagSpec_HtmlFormat = 1
	TagSpec_AMP4ADS TagSpec_HtmlFormat = 2
)

var TagSpec_HtmlFormat_name = map[int32]string{
	1: "AMP",
	2: "AMP4ADS",
}
var TagSpec_HtmlFormat_value = map[string]int32{
	"AMP":     1,
	"AMP4ADS": 2,
}

func (x TagSpec_HtmlFormat) Enum() *TagSpec_HtmlFormat {
	p := new(TagSpec_HtmlFormat)
	*p = x
	return p
}
func (x TagSpec_HtmlFormat) String() string {
	return proto.EnumName(TagSpec_HtmlFormat_name, int32(x))
}
func (x *TagSpec_HtmlFormat) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TagSpec_HtmlFormat_value, data, "TagSpec_HtmlFormat")
	if err != nil {
		return err
	}
	*x = TagSpec_HtmlFormat(value)
	return nil
}

type ErrorCategory_Code int32

const (
	ErrorCategory_UNKNOWN ErrorCategory_Code = 0
	// Errors for which no other category applies are classified as GENERIC.
	ErrorCategory_GENERIC ErrorCategory_Code = 1
	// Disallowed common HTML tags for which there are corresponding
	// AMP tags. E.g., 'img', 'video', 'audio', 'iframe' -> 'amp-img',
	// 'amp-video', 'amp-audio', 'amp-iframe'.
	ErrorCategory_DISALLOWED_HTML_WITH_AMP_EQUIVALENT ErrorCategory_Code = 2
	// Disallowed HTML for which no AMP equivalent exists.
	ErrorCategory_DISALLOWED_HTML ErrorCategory_Code = 3
	// Something is wrong with the author stylesheet, that is, the style
	// tag identified with 'amp-custom'. This includes CSS
	// syntax errors as well as blacklisted CSS features.
	ErrorCategory_AUTHOR_STYLESHEET_PROBLEM ErrorCategory_Code = 4
	// AMP HTML requires specific tags to be present. This includes
	// the invocation of the AMP engine, specific style boilerplate,
	// a viewport declaration, etc.
	ErrorCategory_MANDATORY_AMP_TAG_MISSING_OR_INCORRECT ErrorCategory_Code = 5
	// AMP HTML tags (amp-img, amp-video, amp-brightcove, etc.) require
	// specific attributes, attribute values, etc. Something went wrong
	// with an amp- tag.
	ErrorCategory_AMP_TAG_PROBLEM ErrorCategory_Code = 6
	// We found something wrong with a script tag. Only specific, whitelisted
	// Javascript inclusions are allowed.
	ErrorCategory_CUSTOM_JAVASCRIPT_DISALLOWED ErrorCategory_Code = 7
	// AMP supports layout specifications, such as width and height of
	// a given AMP element, and responsiveness.
	// https://github.com/ampproject/amphtml/blob/master/spec/amp-html-layout.md
	ErrorCategory_AMP_LAYOUT_PROBLEM ErrorCategory_Code = 8
	// AMP supports the HTML template tag (e.g. within amp-list) and interprets
	// Mustache syntax within such templates. To help with debugging, the AMP
	// Validator generates errors for misplaced Mustache template syntax.
	// https://github.com/ampproject/amphtml/blob/master/spec/amp-html-templates.md
	ErrorCategory_AMP_HTML_TEMPLATE_PROBLEM ErrorCategory_Code = 9
	// This is currently still allowed but may soon be disallowed. Usually
	// a recommendation for a replacement is rendered as part of the error.
	ErrorCategory_DEPRECATION ErrorCategory_Code = 10
)

var ErrorCategory_Code_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "GENERIC",
	2:  "DISALLOWED_HTML_WITH_AMP_EQUIVALENT",
	3:  "DISALLOWED_HTML",
	4:  "AUTHOR_STYLESHEET_PROBLEM",
	5:  "MANDATORY_AMP_TAG_MISSING_OR_INCORRECT",
	6:  "AMP_TAG_PROBLEM",
	7:  "CUSTOM_JAVASCRIPT_DISALLOWED",
	8:  "AMP_LAYOUT_PROBLEM",
	9:  "AMP_HTML_TEMPLATE_PROBLEM",
	10: "DEPRECATION",
}
var ErrorCategory_Code_value = map[string]int32{
	"UNKNOWN": 0,
	"GENERIC": 1,
	"DISALLOWED_HTML_WITH_AMP_EQUIVALENT":    2,
	"DISALLOWED_HTML":                        3,
	"AUTHOR_STYLESHEET_PROBLEM":              4,
	"MANDATORY_AMP_TAG_MISSING_OR_INCORRECT": 5,
	"AMP_TAG_PROBLEM":                        6,
	"CUSTOM_JAVASCRIPT_DISALLOWED":           7,
	"AMP_LAYOUT_PROBLEM":                     8,
	"AMP_HTML_TEMPLATE_PROBLEM":              9,
	"DEPRECATION":                            10,
}

func (x ErrorCategory_Code) Enum() *ErrorCategory_Code {
	p := new(ErrorCategory_Code)
	*p = x
	return p
}
func (x ErrorCategory_Code) String() string {
	return proto.EnumName(ErrorCategory_Code_name, int32(x))
}
func (x *ErrorCategory_Code) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ErrorCategory_Code_value, data, "ErrorCategory_Code")
	if err != nil {
		return err
	}
	*x = ErrorCategory_Code(value)
	return nil
}

type ValidationError_Severity int32

const (
	ValidationError_UNKNOWN_SEVERITY ValidationError_Severity = 0
	// A document with at least one error of this severity fails validation.
	ValidationError_ERROR ValidationError_Severity = 1
	// A document may have warnings and still pass validation.
	ValidationError_WARNING ValidationError_Severity = 4
)

var ValidationError_Severity_name = map[int32]string{
	0: "UNKNOWN_SEVERITY",
	1: "ERROR",
	4: "WARNING",
}
var ValidationError_Severity_value = map[string]int32{
	"UNKNOWN_SEVERITY": 0,
	"ERROR":            1,
	"WARNING":          4,
}

func (x ValidationError_Severity) Enum() *ValidationError_Severity {
	p := new(ValidationError_Severity)
	*p = x
	return p
}
func (x ValidationError_Severity) String() string {
	return proto.EnumName(ValidationError_Severity_name, int32(x))
}
func (x *ValidationError_Severity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ValidationError_Severity_value, data, "ValidationError_Severity")
	if err != nil {
		return err
	}
	*x = ValidationError_Severity(value)
	return nil
}

// NEXT AVAILABLE TAG: 83
type ValidationError_Code int32

const (
	ValidationError_UNKNOWN_CODE                                        ValidationError_Code = 0
	ValidationError_MANDATORY_TAG_MISSING                               ValidationError_Code = 1
	ValidationError_TAG_REQUIRED_BY_MISSING                             ValidationError_Code = 24
	ValidationError_WARNING_TAG_REQUIRED_BY_MISSING                     ValidationError_Code = 76
	ValidationError_WARNING_EXTENSION_UNUSED                            ValidationError_Code = 79
	ValidationError_WARNING_EXTENSION_DEPRECATED_VERSION                ValidationError_Code = 80
	ValidationError_ATTR_REQUIRED_BUT_MISSING                           ValidationError_Code = 61
	ValidationError_DISALLOWED_TAG                                      ValidationError_Code = 2
	ValidationError_GENERAL_DISALLOWED_TAG                              ValidationError_Code = 51
	ValidationError_DISALLOWED_ATTR                                     ValidationError_Code = 3
	ValidationError_DISALLOWED_STYLE_ATTR                               ValidationError_Code = 81
	ValidationError_INVALID_ATTR_VALUE                                  ValidationError_Code = 4
	ValidationError_ATTR_VALUE_REQUIRED_BY_LAYOUT                       ValidationError_Code = 27
	ValidationError_IMPLIED_LAYOUT_INVALID                              ValidationError_Code = 22
	ValidationError_SPECIFIED_LAYOUT_INVALID                            ValidationError_Code = 26
	ValidationError_MANDATORY_ATTR_MISSING                              ValidationError_Code = 5
	ValidationError_MANDATORY_ONEOF_ATTR_MISSING                        ValidationError_Code = 28
	ValidationError_DUPLICATE_DIMENSION                                 ValidationError_Code = 60
	ValidationError_DUPLICATE_UNIQUE_TAG                                ValidationError_Code = 6
	ValidationError_DUPLICATE_UNIQUE_TAG_WARNING                        ValidationError_Code = 77
	ValidationError_WRONG_PARENT_TAG                                    ValidationError_Code = 7
	ValidationError_STYLESHEET_TOO_LONG_OLD_VARIANT                     ValidationError_Code = 8
	ValidationError_STYLESHEET_TOO_LONG                                 ValidationError_Code = 50
	ValidationError_MANDATORY_CDATA_MISSING_OR_INCORRECT                ValidationError_Code = 9
	ValidationError_CDATA_VIOLATES_BLACKLIST                            ValidationError_Code = 30
	ValidationError_NON_WHITESPACE_CDATA_ENCOUNTERED                    ValidationError_Code = 82
	ValidationError_DEV_MODE_ENABLED                                    ValidationError_Code = 10
	ValidationError_DEPRECATED_ATTR                                     ValidationError_Code = 11
	ValidationError_DEPRECATED_TAG                                      ValidationError_Code = 12
	ValidationError_MANDATORY_PROPERTY_MISSING_FROM_ATTR_VALUE          ValidationError_Code = 14
	ValidationError_INVALID_PROPERTY_VALUE_IN_ATTR_VALUE                ValidationError_Code = 15
	ValidationError_MISSING_URL                                         ValidationError_Code = 35
	ValidationError_INVALID_URL                                         ValidationError_Code = 36
	ValidationError_INVALID_URL_PROTOCOL                                ValidationError_Code = 37
	ValidationError_DISALLOWED_DOMAIN                                   ValidationError_Code = 62
	ValidationError_DISALLOWED_RELATIVE_URL                             ValidationError_Code = 49
	ValidationError_DISALLOWED_PROPERTY_IN_ATTR_VALUE                   ValidationError_Code = 16
	ValidationError_MUTUALLY_EXCLUSIVE_ATTRS                            ValidationError_Code = 17
	ValidationError_UNESCAPED_TEMPLATE_IN_ATTR_VALUE                    ValidationError_Code = 18
	ValidationError_TEMPLATE_PARTIAL_IN_ATTR_VALUE                      ValidationError_Code = 19
	ValidationError_TEMPLATE_IN_ATTR_NAME                               ValidationError_Code = 20
	ValidationError_INCONSISTENT_UNITS_FOR_WIDTH_AND_HEIGHT             ValidationError_Code = 21
	ValidationError_DISALLOWED_TAG_ANCESTOR                             ValidationError_Code = 23
	ValidationError_MANDATORY_TAG_ANCESTOR                              ValidationError_Code = 31
	ValidationError_MANDATORY_TAG_ANCESTOR_WITH_HINT                    ValidationError_Code = 32
	ValidationError_ATTR_DISALLOWED_BY_IMPLIED_LAYOUT                   ValidationError_Code = 33
	ValidationError_ATTR_DISALLOWED_BY_SPECIFIED_LAYOUT                 ValidationError_Code = 34
	ValidationError_INCORRECT_NUM_CHILD_TAGS                            ValidationError_Code = 56
	ValidationError_DISALLOWED_CHILD_TAG_NAME                           ValidationError_Code = 57
	ValidationError_DISALLOWED_FIRST_CHILD_TAG_NAME                     ValidationError_Code = 58
	ValidationError_DISALLOWED_MANUFACTURED_BODY                        ValidationError_Code = 64
	ValidationError_CHILD_TAG_DOES_NOT_SATISFY_REFERENCE_POINT          ValidationError_Code = 66
	ValidationError_MANDATORY_REFERENCE_POINT_MISSING                   ValidationError_Code = 67
	ValidationError_DUPLICATE_REFERENCE_POINT                           ValidationError_Code = 68
	ValidationError_TAG_REFERENCE_POINT_CONFLICT                        ValidationError_Code = 69
	ValidationError_CHILD_TAG_DOES_NOT_SATISFY_REFERENCE_POINT_SINGULAR ValidationError_Code = 70
	ValidationError_BASE_TAG_MUST_PRECEED_ALL_URLS                      ValidationError_Code = 78
	ValidationError_CSS_SYNTAX                                          ValidationError_Code = 13
	ValidationError_CSS_SYNTAX_INVALID_AT_RULE                          ValidationError_Code = 29
	ValidationError_CSS_SYNTAX_STRAY_TRAILING_BACKSLASH                 ValidationError_Code = 38
	ValidationError_CSS_SYNTAX_UNTERMINATED_COMMENT                     ValidationError_Code = 39
	ValidationError_CSS_SYNTAX_UNTERMINATED_STRING                      ValidationError_Code = 40
	ValidationError_CSS_SYNTAX_BAD_URL                                  ValidationError_Code = 41
	ValidationError_CSS_SYNTAX_EOF_IN_PRELUDE_OF_QUALIFIED_RULE         ValidationError_Code = 42
	ValidationError_CSS_SYNTAX_INVALID_DECLARATION                      ValidationError_Code = 43
	ValidationError_CSS_SYNTAX_INCOMPLETE_DECLARATION                   ValidationError_Code = 44
	ValidationError_CSS_SYNTAX_ERROR_IN_PSEUDO_SELECTOR                 ValidationError_Code = 45
	ValidationError_CSS_SYNTAX_MISSING_SELECTOR                         ValidationError_Code = 46
	ValidationError_CSS_SYNTAX_NOT_A_SELECTOR_START                     ValidationError_Code = 47
	ValidationError_CSS_SYNTAX_UNPARSED_INPUT_REMAINS_IN_SELECTOR       ValidationError_Code = 48
	ValidationError_CSS_SYNTAX_MISSING_URL                              ValidationError_Code = 52
	ValidationError_CSS_SYNTAX_INVALID_URL                              ValidationError_Code = 53
	ValidationError_CSS_SYNTAX_INVALID_URL_PROTOCOL                     ValidationError_Code = 54
	ValidationError_CSS_SYNTAX_DISALLOWED_DOMAIN                        ValidationError_Code = 63
	ValidationError_CSS_SYNTAX_DISALLOWED_RELATIVE_URL                  ValidationError_Code = 55
	ValidationError_CSS_SYNTAX_INVALID_ATTR_SELECTOR                    ValidationError_Code = 59
	// The following codes are currently used only by A4A CSS validation.
	ValidationError_CSS_SYNTAX_DISALLOWED_PROPERTY_VALUE           ValidationError_Code = 71
	ValidationError_CSS_SYNTAX_DISALLOWED_PROPERTY_VALUE_WITH_HINT ValidationError_Code = 72
	ValidationError_CSS_SYNTAX_PROPERTY_DISALLOWED_WITHIN_AT_RULE  ValidationError_Code = 73
	ValidationError_CSS_SYNTAX_PROPERTY_DISALLOWED_TOGETHER_WITH   ValidationError_Code = 74
	ValidationError_CSS_SYNTAX_PROPERTY_REQUIRES_QUALIFICATION     ValidationError_Code = 75
)

var ValidationError_Code_name = map[int32]string{
	0:  "UNKNOWN_CODE",
	1:  "MANDATORY_TAG_MISSING",
	24: "TAG_REQUIRED_BY_MISSING",
	76: "WARNING_TAG_REQUIRED_BY_MISSING",
	79: "WARNING_EXTENSION_UNUSED",
	80: "WARNING_EXTENSION_DEPRECATED_VERSION",
	61: "ATTR_REQUIRED_BUT_MISSING",
	2:  "DISALLOWED_TAG",
	51: "GENERAL_DISALLOWED_TAG",
	3:  "DISALLOWED_ATTR",
	81: "DISALLOWED_STYLE_ATTR",
	4:  "INVALID_ATTR_VALUE",
	27: "ATTR_VALUE_REQUIRED_BY_LAYOUT",
	22: "IMPLIED_LAYOUT_INVALID",
	26: "SPECIFIED_LAYOUT_INVALID",
	5:  "MANDATORY_ATTR_MISSING",
	28: "MANDATORY_ONEOF_ATTR_MISSING",
	60: "DUPLICATE_DIMENSION",
	6:  "DUPLICATE_UNIQUE_TAG",
	77: "DUPLICATE_UNIQUE_TAG_WARNING",
	7:  "WRONG_PARENT_TAG",
	8:  "STYLESHEET_TOO_LONG_OLD_VARIANT",
	50: "STYLESHEET_TOO_LONG",
	9:  "MANDATORY_CDATA_MISSING_OR_INCORRECT",
	30: "CDATA_VIOLATES_BLACKLIST",
	82: "NON_WHITESPACE_CDATA_ENCOUNTERED",
	10: "DEV_MODE_ENABLED",
	11: "DEPRECATED_ATTR",
	12: "DEPRECATED_TAG",
	14: "MANDATORY_PROPERTY_MISSING_FROM_ATTR_VALUE",
	15: "INVALID_PROPERTY_VALUE_IN_ATTR_VALUE",
	35: "MISSING_URL",
	36: "INVALID_URL",
	37: "INVALID_URL_PROTOCOL",
	62: "DISALLOWED_DOMAIN",
	49: "DISALLOWED_RELATIVE_URL",
	16: "DISALLOWED_PROPERTY_IN_ATTR_VALUE",
	17: "MUTUALLY_EXCLUSIVE_ATTRS",
	18: "UNESCAPED_TEMPLATE_IN_ATTR_VALUE",
	19: "TEMPLATE_PARTIAL_IN_ATTR_VALUE",
	20: "TEMPLATE_IN_ATTR_NAME",
	21: "INCONSISTENT_UNITS_FOR_WIDTH_AND_HEIGHT",
	23: "DISALLOWED_TAG_ANCESTOR",
	31: "MANDATORY_TAG_ANCESTOR",
	32: "MANDATORY_TAG_ANCESTOR_WITH_HINT",
	33: "ATTR_DISALLOWED_BY_IMPLIED_LAYOUT",
	34: "ATTR_DISALLOWED_BY_SPECIFIED_LAYOUT",
	56: "INCORRECT_NUM_CHILD_TAGS",
	57: "DISALLOWED_CHILD_TAG_NAME",
	58: "DISALLOWED_FIRST_CHILD_TAG_NAME",
	64: "DISALLOWED_MANUFACTURED_BODY",
	66: "CHILD_TAG_DOES_NOT_SATISFY_REFERENCE_POINT",
	67: "MANDATORY_REFERENCE_POINT_MISSING",
	68: "DUPLICATE_REFERENCE_POINT",
	69: "TAG_REFERENCE_POINT_CONFLICT",
	70: "CHILD_TAG_DOES_NOT_SATISFY_REFERENCE_POINT_SINGULAR",
	78: "BASE_TAG_MUST_PRECEED_ALL_URLS",
	13: "CSS_SYNTAX",
	29: "CSS_SYNTAX_INVALID_AT_RULE",
	38: "CSS_SYNTAX_STRAY_TRAILING_BACKSLASH",
	39: "CSS_SYNTAX_UNTERMINATED_COMMENT",
	40: "CSS_SYNTAX_UNTERMINATED_STRING",
	41: "CSS_SYNTAX_BAD_URL",
	42: "CSS_SYNTAX_EOF_IN_PRELUDE_OF_QUALIFIED_RULE",
	43: "CSS_SYNTAX_INVALID_DECLARATION",
	44: "CSS_SYNTAX_INCOMPLETE_DECLARATION",
	45: "CSS_SYNTAX_ERROR_IN_PSEUDO_SELECTOR",
	46: "CSS_SYNTAX_MISSING_SELECTOR",
	47: "CSS_SYNTAX_NOT_A_SELECTOR_START",
	48: "CSS_SYNTAX_UNPARSED_INPUT_REMAINS_IN_SELECTOR",
	52: "CSS_SYNTAX_MISSING_URL",
	53: "CSS_SYNTAX_INVALID_URL",
	54: "CSS_SYNTAX_INVALID_URL_PROTOCOL",
	63: "CSS_SYNTAX_DISALLOWED_DOMAIN",
	55: "CSS_SYNTAX_DISALLOWED_RELATIVE_URL",
	59: "CSS_SYNTAX_INVALID_ATTR_SELECTOR",
	71: "CSS_SYNTAX_DISALLOWED_PROPERTY_VALUE",
	72: "CSS_SYNTAX_DISALLOWED_PROPERTY_VALUE_WITH_HINT",
	73: "CSS_SYNTAX_PROPERTY_DISALLOWED_WITHIN_AT_RULE",
	74: "CSS_SYNTAX_PROPERTY_DISALLOWED_TOGETHER_WITH",
	75: "CSS_SYNTAX_PROPERTY_REQUIRES_QUALIFICATION",
}
var ValidationError_Code_value = map[string]int32{
	"UNKNOWN_CODE":                                        0,
	"MANDATORY_TAG_MISSING":                               1,
	"TAG_REQUIRED_BY_MISSING":                             24,
	"WARNING_TAG_REQUIRED_BY_MISSING":                     76,
	"WARNING_EXTENSION_UNUSED":                            79,
	"WARNING_EXTENSION_DEPRECATED_VERSION":                80,
	"ATTR_REQUIRED_BUT_MISSING":                           61,
	"DISALLOWED_TAG":                                      2,
	"GENERAL_DISALLOWED_TAG":                              51,
	"DISALLOWED_ATTR":                                     3,
	"DISALLOWED_STYLE_ATTR":                               81,
	"INVALID_ATTR_VALUE":                                  4,
	"ATTR_VALUE_REQUIRED_BY_LAYOUT":                       27,
	"IMPLIED_LAYOUT_INVALID":                              22,
	"SPECIFIED_LAYOUT_INVALID":                            26,
	"MANDATORY_ATTR_MISSING":                              5,
	"MANDATORY_ONEOF_ATTR_MISSING":                        28,
	"DUPLICATE_DIMENSION":                                 60,
	"DUPLICATE_UNIQUE_TAG":                                6,
	"DUPLICATE_UNIQUE_TAG_WARNING":                        77,
	"WRONG_PARENT_TAG":                                    7,
	"STYLESHEET_TOO_LONG_OLD_VARIANT":                     8,
	"STYLESHEET_TOO_LONG":                                 50,
	"MANDATORY_CDATA_MISSING_OR_INCORRECT":                9,
	"CDATA_VIOLATES_BLACKLIST":                            30,
	"NON_WHITESPACE_CDATA_ENCOUNTERED":                    82,
	"DEV_MODE_ENABLED":                                    10,
	"DEPRECATED_ATTR":                                     11,
	"DEPRECATED_TAG":                                      12,
	"MANDATORY_PROPERTY_MISSING_FROM_ATTR_VALUE":          14,
	"INVALID_PROPERTY_VALUE_IN_ATTR_VALUE":                15,
	"MISSING_URL":                                         35,
	"INVALID_URL":                                         36,
	"INVALID_URL_PROTOCOL":                                37,
	"DISALLOWED_DOMAIN":                                   62,
	"DISALLOWED_RELATIVE_URL":                             49,
	"DISALLOWED_PROPERTY_IN_ATTR_VALUE":                   16,
	"MUTUALLY_EXCLUSIVE_ATTRS":                            17,
	"UNESCAPED_TEMPLATE_IN_ATTR_VALUE":                    18,
	"TEMPLATE_PARTIAL_IN_ATTR_VALUE":                      19,
	"TEMPLATE_IN_ATTR_NAME":                               20,
	"INCONSISTENT_UNITS_FOR_WIDTH_AND_HEIGHT":             21,
	"DISALLOWED_TAG_ANCESTOR":                             23,
	"MANDATORY_TAG_ANCESTOR":                              31,
	"MANDATORY_TAG_ANCESTOR_WITH_HINT":                    32,
	"ATTR_DISALLOWED_BY_IMPLIED_LAYOUT":                   33,
	"ATTR_DISALLOWED_BY_SPECIFIED_LAYOUT":                 34,
	"INCORRECT_NUM_CHILD_TAGS":                            56,
	"DISALLOWED_CHILD_TAG_NAME":                           57,
	"DISALLOWED_FIRST_CHILD_TAG_NAME":                     58,
	"DISALLOWED_MANUFACTURED_BODY":                        64,
	"CHILD_TAG_DOES_NOT_SATISFY_REFERENCE_POINT":          66,
	"MANDATORY_REFERENCE_POINT_MISSING":                   67,
	"DUPLICATE_REFERENCE_POINT":                           68,
	"TAG_REFERENCE_POINT_CONFLICT":                        69,
	"CHILD_TAG_DOES_NOT_SATISFY_REFERENCE_POINT_SINGULAR": 70,
	"BASE_TAG_MUST_PRECEED_ALL_URLS":                      78,
	"CSS_SYNTAX":                                          13,
	"CSS_SYNTAX_INVALID_AT_RULE":                          29,
	"CSS_SYNTAX_STRAY_TRAILING_BACKSLASH":                 38,
	"CSS_SYNTAX_UNTERMINATED_COMMENT":                     39,
	"CSS_SYNTAX_UNTERMINATED_STRING":                      40,
	"CSS_SYNTAX_BAD_URL":                                  41,
	"CSS_SYNTAX_EOF_IN_PRELUDE_OF_QUALIFIED_RULE":         42,
	"CSS_SYNTAX_INVALID_DECLARATION":                      43,
	"CSS_SYNTAX_INCOMPLETE_DECLARATION":                   44,
	"CSS_SYNTAX_ERROR_IN_PSEUDO_SELECTOR":                 45,
	"CSS_SYNTAX_MISSING_SELECTOR":                         46,
	"CSS_SYNTAX_NOT_A_SELECTOR_START":                     47,
	"CSS_SYNTAX_UNPARSED_INPUT_REMAINS_IN_SELECTOR":       48,
	"CSS_SYNTAX_MISSING_URL":                              52,
	"CSS_SYNTAX_INVALID_URL":                              53,
	"CSS_SYNTAX_INVALID_URL_PROTOCOL":                     54,
	"CSS_SYNTAX_DISALLOWED_DOMAIN":                        63,
	"CSS_SYNTAX_DISALLOWED_RELATIVE_URL":                  55,
	"CSS_SYNTAX_INVALID_ATTR_SELECTOR":                    59,
	"CSS_SYNTAX_DISALLOWED_PROPERTY_VALUE":                71,
	"CSS_SYNTAX_DISALLOWED_PROPERTY_VALUE_WITH_HINT":      72,
	"CSS_SYNTAX_PROPERTY_DISALLOWED_WITHIN_AT_RULE":       73,
	"CSS_SYNTAX_PROPERTY_DISALLOWED_TOGETHER_WITH":        74,
	"CSS_SYNTAX_PROPERTY_REQUIRES_QUALIFICATION":          75,
}

func (x ValidationError_Code) Enum() *ValidationError_Code {
	p := new(ValidationError_Code)
	*p = x
	return p
}
func (x ValidationError_Code) String() string {
	return proto.EnumName(ValidationError_Code_name, int32(x))
}
func (x *ValidationError_Code) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ValidationError_Code_value, data, "ValidationError_Code")
	if err != nil {
		return err
	}
	*x = ValidationError_Code(value)
	return nil
}

type ValidationResult_Status int32

const (
	ValidationResult_UNKNOWN ValidationResult_Status = 0
	ValidationResult_PASS    ValidationResult_Status = 1
	ValidationResult_FAIL    ValidationResult_Status = 2
)

var ValidationResult_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "PASS",
	2: "FAIL",
}
var ValidationResult_Status_value = map[string]int32{
	"UNKNOWN": 0,
	"PASS":    1,
	"FAIL":    2,
}

func (x ValidationResult_Status) Enum() *ValidationResult_Status {
	p := new(ValidationResult_Status)
	*p = x
	return p
}
func (x ValidationResult_Status) String() string {
	return proto.EnumName(ValidationResult_Status_name, int32(x))
}
func (x *ValidationResult_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ValidationResult_Status_value, data, "ValidationResult_Status")
	if err != nil {
		return err
	}
	*x = ValidationResult_Status(value)
	return nil
}

// Used for validating attributes that require another attribute for some
// given set of conditions.
// E.g. attr name: "on" if_value_regex: "tap:.*" also_require_attr: "role"
type AttrTriggerSpec struct {
	// If set, attribute's value must match to also require attribute(s).
	// If not set, attribute automatically also require attribute(s).
	IfValueRegex *string `protobuf:"bytes,1,opt,name=if_value_regex" json:"if_value_regex,omitempty"`
	// If set, other attributes - identified by their name string - must
	// be present as well.
	AlsoRequiresAttr []string `protobuf:"bytes,2,rep,name=also_requires_attr" json:"also_requires_attr,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *AttrTriggerSpec) Reset()         { *m = AttrTriggerSpec{} }
func (m *AttrTriggerSpec) String() string { return proto.CompactTextString(m) }
func (*AttrTriggerSpec) ProtoMessage()    {}

func (m *AttrTriggerSpec) GetIfValueRegex() string {
	if m != nil && m.IfValueRegex != nil {
		return *m.IfValueRegex
	}
	return ""
}

func (m *AttrTriggerSpec) GetAlsoRequiresAttr() []string {
	if m != nil {
		return m.AlsoRequiresAttr
	}
	return nil
}

// Used for validating properties in attribute values. Our validator
// (via parse-viewport.h) implements the parsing algorithm as described here:
// https://drafts.csswg.org/css-device-adapt/#parsing-algorithm
type PropertySpec struct {
	// Must be lowercase, and will be matched case-insensitively.
	Name      *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Mandatory *bool   `protobuf:"varint,2,opt,name=mandatory" json:"mandatory,omitempty"`
	// Must be lowercase, and will be matched case-insensitively.
	Value            *string  `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	ValueDouble      *float64 `protobuf:"fixed64,4,opt,name=value_double" json:"value_double,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PropertySpec) Reset()         { *m = PropertySpec{} }
func (m *PropertySpec) String() string { return proto.CompactTextString(m) }
func (*PropertySpec) ProtoMessage()    {}

func (m *PropertySpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *PropertySpec) GetMandatory() bool {
	if m != nil && m.Mandatory != nil {
		return *m.Mandatory
	}
	return false
}

func (m *PropertySpec) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *PropertySpec) GetValueDouble() float64 {
	if m != nil && m.ValueDouble != nil {
		return *m.ValueDouble
	}
	return 0
}

type PropertySpecList struct {
	Properties       []*PropertySpec `protobuf:"bytes,1,rep,name=properties" json:"properties,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *PropertySpecList) Reset()         { *m = PropertySpecList{} }
func (m *PropertySpecList) String() string { return proto.CompactTextString(m) }
func (*PropertySpecList) ProtoMessage()    {}

func (m *PropertySpecList) GetProperties() []*PropertySpec {
	if m != nil {
		return m.Properties
	}
	return nil
}

// Used for validating urls in attribute values (such as href/src/srcset).
type UrlSpec struct {
	// allowed_protocol must be in lowercase (e.g. "javascript" not "JavaScript").
	AllowedProtocol []string `protobuf:"bytes,1,rep,name=allowed_protocol" json:"allowed_protocol,omitempty"`
	AllowRelative   *bool    `protobuf:"varint,2,opt,name=allow_relative,def=1" json:"allow_relative,omitempty"`
	// Whether the empty string '' is allowed for this URL value.
	AllowEmpty *bool `protobuf:"varint,3,opt,name=allow_empty,def=0" json:"allow_empty,omitempty"`
	// Must be lowercase. Subdomains of disallowed domains are also disallowed,
	// so if 'example.com' is disallowed then 'www.example.com' is also disallowed
	// but 'some-example.com' is allowed.
	DisallowedDomain []string `protobuf:"bytes,4,rep,name=disallowed_domain" json:"disallowed_domain,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *UrlSpec) Reset()         { *m = UrlSpec{} }
func (m *UrlSpec) String() string { return proto.CompactTextString(m) }
func (*UrlSpec) ProtoMessage()    {}

const Default_UrlSpec_AllowRelative bool = true
const Default_UrlSpec_AllowEmpty bool = false

func (m *UrlSpec) GetAllowedProtocol() []string {
	if m != nil {
		return m.AllowedProtocol
	}
	return nil
}

func (m *UrlSpec) GetAllowRelative() bool {
	if m != nil && m.AllowRelative != nil {
		return *m.AllowRelative
	}
	return Default_UrlSpec_AllowRelative
}

func (m *UrlSpec) GetAllowEmpty() bool {
	if m != nil && m.AllowEmpty != nil {
		return *m.AllowEmpty
	}
	return Default_UrlSpec_AllowEmpty
}

func (m *UrlSpec) GetDisallowedDomain() []string {
	if m != nil {
		return m.DisallowedDomain
	}
	return nil
}

// Attributes that are not covered by at least one of these specs are
// disallowed. Within a given context (e.g., for a given TagSpec),
// names are unique.
// NEXT AVAILABLE TAG: 19
type AttrSpec struct {
	// Use lower-case attribute names only.
	Name             *string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	AlternativeNames []string `protobuf:"bytes,2,rep,name=alternative_names" json:"alternative_names,omitempty"`
	Mandatory        *bool    `protobuf:"varint,3,opt,name=mandatory" json:"mandatory,omitempty"`
	// Within the context of the tag, exactly one of the attributes tagged
	// with this identifier must be present. Per convention, this identifier
	// should list the tags participating in the mandatory oneof, with or,
	// e.g. "foo or bar or baz".
	MandatoryOneof *string `protobuf:"bytes,12,opt,name=mandatory_oneof" json:"mandatory_oneof,omitempty"`
	// The attribute value must be equal to the value in this field.
	Value           *string  `protobuf:"bytes,4,opt,name=value" json:"value,omitempty"`
	ValueCasei      *string  `protobuf:"bytes,18,opt,name=value_casei" json:"value_casei,omitempty"`
	ValueRegex      *string  `protobuf:"bytes,15,opt,name=value_regex" json:"value_regex,omitempty"`
	ValueRegexCasei *string  `protobuf:"bytes,5,opt,name=value_regex_casei" json:"value_regex_casei,omitempty"`
	ValueUrl        *UrlSpec `protobuf:"bytes,14,opt,name=value_url" json:"value_url,omitempty"`
	// validates against a list of properties (see PropertySpec).
	ValueProperties *PropertySpecList `protobuf:"bytes,11,opt,name=value_properties" json:"value_properties,omitempty"`
	Trigger         *AttrTriggerSpec  `protobuf:"bytes,16,opt,name=trigger" json:"trigger,omitempty"`
	// If set, then the attribute value may not match this regex, which is
	// always applied case-insensitively and as a partial match.
	BlacklistedValueRegex *string `protobuf:"bytes,6,opt,name=blacklisted_value_regex" json:"blacklisted_value_regex,omitempty"`
	// If set, generates a DEPRECATED_ATTR error with severity WARNING.
	// The value of the deprecation field indicates what to use instead,
	// e.g. the name of an attribute or tag.
	Deprecation *string `protobuf:"bytes,7,opt,name=deprecation" json:"deprecation,omitempty"`
	// If provided, a URL which links to the AMP HTML spec for this deprecation.
	DeprecationUrl *string `protobuf:"bytes,8,opt,name=deprecation_url" json:"deprecation_url,omitempty"`
	// If set true, the TagSpec containing this AttrSpec will be evaluated first
	// for any encountered tag which matches the tag name and this attribute spec.
	// May only be set for an AttrSpec where mandatory=true and the value field
	// is set.
	DispatchKey *bool `protobuf:"varint,13,opt,name=dispatch_key" json:"dispatch_key,omitempty"`
	// If set to true, the TagSpec containing this AttrSpec implicitly has this
	// attribute and the attribute is considered valid.
	Implicit         *bool  `protobuf:"varint,17,opt,name=implicit,def=0" json:"implicit,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *AttrSpec) Reset()         { *m = AttrSpec{} }
func (m *AttrSpec) String() string { return proto.CompactTextString(m) }
func (*AttrSpec) ProtoMessage()    {}

const Default_AttrSpec_Implicit bool = false

func (m *AttrSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AttrSpec) GetAlternativeNames() []string {
	if m != nil {
		return m.AlternativeNames
	}
	return nil
}

func (m *AttrSpec) GetMandatory() bool {
	if m != nil && m.Mandatory != nil {
		return *m.Mandatory
	}
	return false
}

func (m *AttrSpec) GetMandatoryOneof() string {
	if m != nil && m.MandatoryOneof != nil {
		return *m.MandatoryOneof
	}
	return ""
}

func (m *AttrSpec) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *AttrSpec) GetValueCasei() string {
	if m != nil && m.ValueCasei != nil {
		return *m.ValueCasei
	}
	return ""
}

func (m *AttrSpec) GetValueRegex() string {
	if m != nil && m.ValueRegex != nil {
		return *m.ValueRegex
	}
	return ""
}

func (m *AttrSpec) GetValueRegexCasei() string {
	if m != nil && m.ValueRegexCasei != nil {
		return *m.ValueRegexCasei
	}
	return ""
}

func (m *AttrSpec) GetValueUrl() *UrlSpec {
	if m != nil {
		return m.ValueUrl
	}
	return nil
}

func (m *AttrSpec) GetValueProperties() *PropertySpecList {
	if m != nil {
		return m.ValueProperties
	}
	return nil
}

func (m *AttrSpec) GetTrigger() *AttrTriggerSpec {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *AttrSpec) GetBlacklistedValueRegex() string {
	if m != nil && m.BlacklistedValueRegex != nil {
		return *m.BlacklistedValueRegex
	}
	return ""
}

func (m *AttrSpec) GetDeprecation() string {
	if m != nil && m.Deprecation != nil {
		return *m.Deprecation
	}
	return ""
}

func (m *AttrSpec) GetDeprecationUrl() string {
	if m != nil && m.DeprecationUrl != nil {
		return *m.DeprecationUrl
	}
	return ""
}

func (m *AttrSpec) GetDispatchKey() bool {
	if m != nil && m.DispatchKey != nil {
		return *m.DispatchKey
	}
	return false
}

func (m *AttrSpec) GetImplicit() bool {
	if m != nil && m.Implicit != nil {
		return *m.Implicit
	}
	return Default_AttrSpec_Implicit
}

// Some tags share several attributes, so they're identified by unique key
// (see the attr_lists map in ValidatorRules).
type AttrList struct {
	Name             *string     `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Attrs            []*AttrSpec `protobuf:"bytes,2,rep,name=attrs" json:"attrs,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *AttrList) Reset()         { *m = AttrList{} }
func (m *AttrList) String() string { return proto.CompactTextString(m) }
func (*AttrList) ProtoMessage()    {}

func (m *AttrList) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AttrList) GetAttrs() []*AttrSpec {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// Regex which, if matches the cdata of a tag, causes the tag validation to
// fail.
type BlackListedCDataRegex struct {
	// Syntax is partial match, use ^ and $ if you want global match.
	Regex            *string `protobuf:"bytes,1,opt,name=regex" json:"regex,omitempty"`
	ErrorMessage     *string `protobuf:"bytes,2,opt,name=error_message" json:"error_message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlackListedCDataRegex) Reset()         { *m = BlackListedCDataRegex{} }
func (m *BlackListedCDataRegex) String() string { return proto.CompactTextString(m) }
func (*BlackListedCDataRegex) ProtoMessage()    {}

func (m *BlackListedCDataRegex) GetRegex() string {
	if m != nil && m.Regex != nil {
		return *m.Regex
	}
	return ""
}

func (m *BlackListedCDataRegex) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

// This spec is used by our CSS parser to determine how the contents of a given
// AT rule should be parsed, if at all. The term 'rule' here refers to the AT
// Rule in CSS, not a validation rule.
type AtRuleSpec struct {
	// Name of the AT rule to parse. Do not include the '@' symbol (e.g. '@media'
	// should be encoded as 'media'. A value of '$DEFAULT' indicates the default
	// AT rule which will match any AT rule not present in any other AtRuleSpec.
	Name             *string               `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type             *AtRuleSpec_BlockType `protobuf:"varint,2,opt,name=type,enum=amp.validator.AtRuleSpec_BlockType,def=0" json:"type,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *AtRuleSpec) Reset()         { *m = AtRuleSpec{} }
func (m *AtRuleSpec) String() string { return proto.CompactTextString(m) }
func (*AtRuleSpec) ProtoMessage()    {}

const Default_AtRuleSpec_Type AtRuleSpec_BlockType = AtRuleSpec_PARSE_AS_ERROR

func (m *AtRuleSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AtRuleSpec) GetType() AtRuleSpec_BlockType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_AtRuleSpec_Type
}

// NEXT AVAILABLE TAG: 6
type CssSpec struct {
	// Spec for how to parse CSS AT rules, one per AT rule. Must not contain
	// duplicate names, and must contain at least one entry for the default.
	AtRuleSpec []*AtRuleSpec `protobuf:"bytes,1,rep,name=at_rule_spec" json:"at_rule_spec,omitempty"`
	// urls within the CSS are checked against this spec.
	ImageUrlSpec *UrlSpec `protobuf:"bytes,3,opt,name=image_url_spec" json:"image_url_spec,omitempty"`
	FontUrlSpec  *UrlSpec `protobuf:"bytes,4,opt,name=font_url_spec" json:"font_url_spec,omitempty"`
	// Enables checks specific to the draft A4A specification.
	// TODO(powdercloud): Make this more generic.
	ValidateAmp4Ads  *bool  `protobuf:"varint,5,opt,name=validate_amp4ads" json:"validate_amp4ads,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CssSpec) Reset()         { *m = CssSpec{} }
func (m *CssSpec) String() string { return proto.CompactTextString(m) }
func (*CssSpec) ProtoMessage()    {}

func (m *CssSpec) GetAtRuleSpec() []*AtRuleSpec {
	if m != nil {
		return m.AtRuleSpec
	}
	return nil
}

func (m *CssSpec) GetImageUrlSpec() *UrlSpec {
	if m != nil {
		return m.ImageUrlSpec
	}
	return nil
}

func (m *CssSpec) GetFontUrlSpec() *UrlSpec {
	if m != nil {
		return m.FontUrlSpec
	}
	return nil
}

func (m *CssSpec) GetValidateAmp4Ads() bool {
	if m != nil && m.ValidateAmp4Ads != nil {
		return *m.ValidateAmp4Ads
	}
	return false
}

// NEXT AVAILABLE TAG: 9
type CdataSpec struct {
	// If set, the cdata contents cannot be greater than this length, in bytes.
	MaxBytes *int32 `protobuf:"varint,1,opt,name=max_bytes,def=-1" json:"max_bytes,omitempty"`
	// If provided, a URL which linking to a section / sentence in the
	// AMP HTML spec.
	MaxBytesSpecUrl *string `protobuf:"bytes,2,opt,name=max_bytes_spec_url" json:"max_bytes_spec_url,omitempty"`
	// If non-empty, the text between the start / end tag must match this value.
	MandatoryCdata *string `protobuf:"bytes,3,opt,name=mandatory_cdata" json:"mandatory_cdata,omitempty"`
	// If non-empty, the text between the start / end tag must match this regex.
	CdataRegex *string `protobuf:"bytes,6,opt,name=cdata_regex" json:"cdata_regex,omitempty"`
	// If at least one CssSpec is provided, this cdata field will be parsed
	// as CSS3, and any parsing errors will become validation errors.
	CssSpec *CssSpec `protobuf:"bytes,7,opt,name=css_spec" json:"css_spec,omitempty"`
	// If set to true, then only whitespace may be in the cdata contents.
	// This is useful for script tags that reference extensions etc.
	WhitespaceOnly *bool `protobuf:"varint,8,opt,name=whitespace_only" json:"whitespace_only,omitempty"`
	// If any of these regexes match, then this cdata spec does not validate.
	BlacklistedCdataRegex []*BlackListedCDataRegex `protobuf:"bytes,4,rep,name=blacklisted_cdata_regex" json:"blacklisted_cdata_regex,omitempty"`
	XXX_unrecognized      []byte                   `json:"-"`
}

func (m *CdataSpec) Reset()         { *m = CdataSpec{} }
func (m *CdataSpec) String() string { return proto.CompactTextString(m) }
func (*CdataSpec) ProtoMessage()    {}

const Default_CdataSpec_MaxBytes int32 = -1

func (m *CdataSpec) GetMaxBytes() int32 {
	if m != nil && m.MaxBytes != nil {
		return *m.MaxBytes
	}
	return Default_CdataSpec_MaxBytes
}

func (m *CdataSpec) GetMaxBytesSpecUrl() string {
	if m != nil && m.MaxBytesSpecUrl != nil {
		return *m.MaxBytesSpecUrl
	}
	return ""
}

func (m *CdataSpec) GetMandatoryCdata() string {
	if m != nil && m.MandatoryCdata != nil {
		return *m.MandatoryCdata
	}
	return ""
}

func (m *CdataSpec) GetCdataRegex() string {
	if m != nil && m.CdataRegex != nil {
		return *m.CdataRegex
	}
	return ""
}

func (m *CdataSpec) GetCssSpec() *CssSpec {
	if m != nil {
		return m.CssSpec
	}
	return nil
}

func (m *CdataSpec) GetWhitespaceOnly() bool {
	if m != nil && m.WhitespaceOnly != nil {
		return *m.WhitespaceOnly
	}
	return false
}

func (m *CdataSpec) GetBlacklistedCdataRegex() []*BlackListedCDataRegex {
	if m != nil {
		return m.BlacklistedCdataRegex
	}
	return nil
}

// Specifies which AMP Layouts are supported by a given element.
// For the purpose of the validator, this specifies which
// values for layout, height, and width attributes are allowed. Also see
// https://github.com/ampproject/amphtml/blob/master/spec/amp-html-layout.md
// TODO(johannes): Make the error messages around layouts better. This
// may require revamping the documentation for elements and/or the above spec,
// so that a user gets more clearly informed about which layouts are
// applicable to a given tag, what happens when layout attribute or other
// attributes are not set, etc.
type AmpLayout struct {
	// Specifies which layouts are supported by this element.
	SupportedLayouts []AmpLayout_Layout `protobuf:"varint,1,rep,name=supported_layouts,enum=amp.validator.AmpLayout_Layout" json:"supported_layouts,omitempty"`
	// Specifies whether this element has default dimensions. This corresponds
	// to being whitelisted in naturalDimensions_ in
	// https://github.com/ampproject/amphtml/blob/master/src/layout.js.
	DefinesDefaultWidth  *bool  `protobuf:"varint,2,opt,name=defines_default_width" json:"defines_default_width,omitempty"`
	DefinesDefaultHeight *bool  `protobuf:"varint,3,opt,name=defines_default_height" json:"defines_default_height,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *AmpLayout) Reset()         { *m = AmpLayout{} }
func (m *AmpLayout) String() string { return proto.CompactTextString(m) }
func (*AmpLayout) ProtoMessage()    {}

func (m *AmpLayout) GetSupportedLayouts() []AmpLayout_Layout {
	if m != nil {
		return m.SupportedLayouts
	}
	return nil
}

func (m *AmpLayout) GetDefinesDefaultWidth() bool {
	if m != nil && m.DefinesDefaultWidth != nil {
		return *m.DefinesDefaultWidth
	}
	return false
}

func (m *AmpLayout) GetDefinesDefaultHeight() bool {
	if m != nil && m.DefinesDefaultHeight != nil {
		return *m.DefinesDefaultHeight
	}
	return false
}

// TagSpec::child_tags uses this configuration to specify which child tags
// are expected for a specific tag.
//
// Matching child tags is done by tag name, while the parent is
// matched by TagSpec. The reason for this is that matching by tag
// spec name would produce less useful error messages, because we want
// to be able to produce a good message even if the tag spec name
// could not be determined because the enclosed child tag is invalid
// (no TagSpec matches). By doing a tag name match, we can produce a
// reasonable error regardless if a child tag was misplaced.
type ChildTagSpec struct {
	// Unless set to -1 (the default), the parent tag must have exactly
	// |mandatory_num_child_tags| immediate child tags.
	MandatoryNumChildTags *int32 `protobuf:"varint,1,opt,name=mandatory_num_child_tags,def=-1" json:"mandatory_num_child_tags,omitempty"`
	// If at least one tag name is specified, then the first child of the
	// parent tag must have one of the provided names.
	FirstChildTagNameOneof []string `protobuf:"bytes,2,rep,name=first_child_tag_name_oneof" json:"first_child_tag_name_oneof,omitempty"`
	// If at least one tag name is specified, then the child tags of
	// the parent tag must have one of the provided tag names.
	ChildTagNameOneof []string `protobuf:"bytes,3,rep,name=child_tag_name_oneof" json:"child_tag_name_oneof,omitempty"`
	XXX_unrecognized  []byte   `json:"-"`
}

func (m *ChildTagSpec) Reset()         { *m = ChildTagSpec{} }
func (m *ChildTagSpec) String() string { return proto.CompactTextString(m) }
func (*ChildTagSpec) ProtoMessage()    {}

const Default_ChildTagSpec_MandatoryNumChildTags int32 = -1

func (m *ChildTagSpec) GetMandatoryNumChildTags() int32 {
	if m != nil && m.MandatoryNumChildTags != nil {
		return *m.MandatoryNumChildTags
	}
	return Default_ChildTagSpec_MandatoryNumChildTags
}

func (m *ChildTagSpec) GetFirstChildTagNameOneof() []string {
	if m != nil {
		return m.FirstChildTagNameOneof
	}
	return nil
}

func (m *ChildTagSpec) GetChildTagNameOneof() []string {
	if m != nil {
		return m.ChildTagNameOneof
	}
	return nil
}

// TagSpecs and reference points.
//
// Any TagSpec may define a list of reference points via the
// TagSpec::reference_points field. These reference points specify how
// DOM elements that are children of this parent tag fulfill particular
// functionality. For instance, a widget (implemented as an AMP tag) may
// require a login reference point. Any valid AMP tag would be allowed,
// whether it's a clickable DIV or an AMP-IMG or a BUTTON, so long as
// it *also* conforms to the reference point specification. This
// specification is a TagSpec which does not define a name (the
// name is set to the special value '$REFERENCE_POINT'), but rather
// identifies the reference point with AttrSpec requirements. For instance,
// the login reference point may require that there be a login attribute,
// or some end-point attribute with a URL, or similar.
// Therefore, for any child tags of a tag that defines reference points,
// they are first matched against these reference points, and only
// then are they validated as regular tags against the TagSpecs that are
// not reference points while their reference point attributes are skipped.
// The complexity of this mechanism is unfortunate but reduces the markup
// required and makes CSS styling more convenient. Please see
// the amp-live-list specification for an example.
type ReferencePoint struct {
	// A tag spec identified by its TagSpec::spec_name which specifies how
	// a specific functionality for the parent tag is assigned.
	TagSpecName *string `protobuf:"bytes,1,opt,name=tag_spec_name" json:"tag_spec_name,omitempty"`
	// At least one of the child tags of the parent defining this
	// reference point must match it.
	Mandatory *bool `protobuf:"varint,2,opt,name=mandatory" json:"mandatory,omitempty"`
	// At most one of the child tags of the parent defining this
	// reference point must match it.
	Unique           *bool  `protobuf:"varint,3,opt,name=unique" json:"unique,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReferencePoint) Reset()         { *m = ReferencePoint{} }
func (m *ReferencePoint) String() string { return proto.CompactTextString(m) }
func (*ReferencePoint) ProtoMessage()    {}

func (m *ReferencePoint) GetTagSpecName() string {
	if m != nil && m.TagSpecName != nil {
		return *m.TagSpecName
	}
	return ""
}

func (m *ReferencePoint) GetMandatory() bool {
	if m != nil && m.Mandatory != nil {
		return *m.Mandatory
	}
	return false
}

func (m *ReferencePoint) GetUnique() bool {
	if m != nil && m.Unique != nil {
		return *m.Unique
	}
	return false
}

// Specs specific to AMP Extensions. This is a field within TagSpec that
// replaces the standard tagspec list of attributes, requirements, etc.
// NEXT AVAILABLE TAG: 7
type ExtensionSpec struct {
	// e.g. "amp-video". This is used both as the attribute value for the
	// 'custom-element' attribute value as well as part of the 'src' attribute
	// value.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// e.g. "0.1", "1.0", "latest".
	AllowedVersions []string `protobuf:"bytes,2,rep,name=allowed_versions" json:"allowed_versions,omitempty"`
	// deprecated_versions must be a strict subset of allowed_versions. If
	// the version matches a deprecated_versions field, validation will emit
	// a warning.
	DeprecatedVersions []string `protobuf:"bytes,3,rep,name=deprecated_versions" json:"deprecated_versions,omitempty"`
	// Most extensions are custom-elements. For custom-template extensions, this
	// value needs to be set true. E.g: amp-mustache.
	IsCustomTemplate *bool `protobuf:"varint,4,opt,name=is_custom_template,def=0" json:"is_custom_template,omitempty"`
	// For older tags, implemented before the 'requires' TagSpec feature,
	// we use deprecated_recommends_usage_of_tag to emit a warning if the
	// TagSpec is unused. New tags should set 'requires' in the TagSpec to some
	// string to enforce that the tag is used.
	//
	// Some extensions, such as `amp-dynamic-css-classes`, do not have an
	// associated tag in the document indicating usage. For such tags, both
	// of these may be unset.
	DeprecatedRecommendsUsageOfTag []string `protobuf:"bytes,5,rep,name=deprecated_recommends_usage_of_tag" json:"deprecated_recommends_usage_of_tag,omitempty"`
	// For older tags, we did not originally require that the tag only be included
	// once, so those tags are grandfathered in for multiple inclusion in the file
	DeprecatedAllowDuplicates *bool  `protobuf:"varint,6,opt,name=deprecated_allow_duplicates,def=0" json:"deprecated_allow_duplicates,omitempty"`
	XXX_unrecognized          []byte `json:"-"`
}

func (m *ExtensionSpec) Reset()         { *m = ExtensionSpec{} }
func (m *ExtensionSpec) String() string { return proto.CompactTextString(m) }
func (*ExtensionSpec) ProtoMessage()    {}

const Default_ExtensionSpec_IsCustomTemplate bool = false
const Default_ExtensionSpec_DeprecatedAllowDuplicates bool = false

func (m *ExtensionSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExtensionSpec) GetAllowedVersions() []string {
	if m != nil {
		return m.AllowedVersions
	}
	return nil
}

func (m *ExtensionSpec) GetDeprecatedVersions() []string {
	if m != nil {
		return m.DeprecatedVersions
	}
	return nil
}

func (m *ExtensionSpec) GetIsCustomTemplate() bool {
	if m != nil && m.IsCustomTemplate != nil {
		return *m.IsCustomTemplate
	}
	return Default_ExtensionSpec_IsCustomTemplate
}

func (m *ExtensionSpec) GetDeprecatedRecommendsUsageOfTag() []string {
	if m != nil {
		return m.DeprecatedRecommendsUsageOfTag
	}
	return nil
}

func (m *ExtensionSpec) GetDeprecatedAllowDuplicates() bool {
	if m != nil && m.DeprecatedAllowDuplicates != nil {
		return *m.DeprecatedAllowDuplicates
	}
	return Default_ExtensionSpec_DeprecatedAllowDuplicates
}

// Tags that are not covered by at least one of these specs are disallowed.
// Some tags are mandatory. Note that the tag name is not unique, that is,
// there can be multiple tag specs covering the same name, e.g., for
// multiple meta tags (with different attributes).
// NEXT AVAILABLE TAG: 28
type TagSpec struct {
	// Specifies which amp html document formats we allow this TagSpec to
	// validate.
	HtmlFormat []TagSpec_HtmlFormat `protobuf:"varint,21,rep,name=html_format,enum=amp.validator.TagSpec_HtmlFormat" json:"html_format,omitempty"`
	// Use UPPER-CASE tag names only. If adding the same tag twice, then they must
	// also have a spec_name string which is unique throughout all detail.
	// Note: "$REFERENCE_POINT" is a special tag_name value.
	//       Reference points are partial tag specs which don't have a defined
	//       tag_name.
	TagName *string `protobuf:"bytes,1,opt,name=tag_name" json:"tag_name,omitempty"`
	// If provided, the spec_name must be unique within the validator
	// rules. It will be used with preference over the tag_name in
	// parameters for error messages and other usages that require or
	// benefit from a unique identifier.
	SpecName *string `protobuf:"bytes,2,opt,name=spec_name" json:"spec_name,omitempty"`
	// If provided, this is a SCRIPT tag defining an amp custom element
	// extension. The other fields, such as expected attributes, will be
	// validated by the extension spec rules.
	ExtensionSpec *ExtensionSpec `protobuf:"bytes,27,opt,name=extension_spec" json:"extension_spec,omitempty"`
	// If true, a tag conforming to this tag spec must occur at least once
	// within the document.
	Mandatory *bool `protobuf:"varint,3,opt,name=mandatory" json:"mandatory,omitempty"`
	// A string identifying that this tag belongs to a set of alternative
	// choices from which at least one needs to be satisfied.
	MandatoryAlternatives *string `protobuf:"bytes,4,opt,name=mandatory_alternatives" json:"mandatory_alternatives,omitempty"`
	// If true, a tag conforming to this tag spec may occur at most once within
	// the document.
	Unique *bool `protobuf:"varint,5,opt,name=unique" json:"unique,omitempty"`
	// If true, a tag conforming to this tag spec should occur at most once within
	// the document. That is, unlike for unique, we'll emit a warning.
	UniqueWarning *bool `protobuf:"varint,25,opt,name=unique_warning" json:"unique_warning,omitempty"`
	// If set to "$ROOT", this tag must be the root tag.
	// If set to any other string, the tag must be the direct child of the
	//   specified mandatory parent tag.
	MandatoryParent *string `protobuf:"bytes,6,opt,name=mandatory_parent" json:"mandatory_parent,omitempty"`
	// If set, the tag must descend from (not necessarily direct parent of) the
	// specified mandatory parent string.
	MandatoryAncestor *string `protobuf:"bytes,15,opt,name=mandatory_ancestor" json:"mandatory_ancestor,omitempty"`
	// Use only for tags where mandatory_ancestor is set. If tag validation fails
	// due to the mandatory_ancestor, and this field is set, then the error
	// detail will suggest the tag specified here as an alternative to consider.
	MandatoryAncestorSuggestedAlternative *string `protobuf:"bytes,16,opt,name=mandatory_ancestor_suggested_alternative" json:"mandatory_ancestor_suggested_alternative,omitempty"`
	// This tag may not descend from any tag with any of these tag names.
	DisallowedAncestor []string `protobuf:"bytes,13,rep,name=disallowed_ancestor" json:"disallowed_ancestor,omitempty"`
	// If set, other tags - identified by their detail string - must be
	// present as well or a warning will be issued (will not invalidate doc).
	AlsoRequiresTagWarning []string `protobuf:"bytes,22,rep,name=also_requires_tag_warning" json:"also_requires_tag_warning,omitempty"`
	// Expresses a generic condition which is satisfied if this tag is found. Used
	// in combination with the `requires` attribute on a different tag.
	Satisfies []string `protobuf:"bytes,23,rep,name=satisfies" json:"satisfies,omitempty"`
	// Expresses a generic condition which must be satisfied if this tag is found.
	// Used in combination with the `satisfies` attributes on a different tag.
	Requires []string `protobuf:"bytes,24,rep,name=requires" json:"requires,omitempty"`
	// If set, generates a DEPRECATED_TAG error with severity WARNING.
	// The value of the deprecation field indicates what to use instead,
	// e.g. the name of a tag.
	Deprecation *string `protobuf:"bytes,17,opt,name=deprecation" json:"deprecation,omitempty"`
	// If provided, a URL which links to the AMP HTML spec for this deprecation.
	DeprecationUrl *string `protobuf:"bytes,18,opt,name=deprecation_url" json:"deprecation_url,omitempty"`
	// Attribute specifications related to this tag.
	Attrs []*AttrSpec `protobuf:"bytes,7,rep,name=attrs" json:"attrs,omitempty"`
	// Top level attr lists of shared tags, identified by unique key
	// (see attr_lists map in ValidatorRules).
	AttrLists []string `protobuf:"bytes,8,rep,name=attr_lists" json:"attr_lists,omitempty"`
	// Note that these are evaluated after a particular TagSpec
	// has been evaluated. Unlike other checks in this TagSpec, we
	// no longer have the ability to fall back on a different TagSpec.
	Cdata *CdataSpec `protobuf:"bytes,12,opt,name=cdata" json:"cdata,omitempty"`
	// Specifies which tags can be the child tags, that is, immediately children
	// of this tag in the document.
	ChildTags *ChildTagSpec `protobuf:"bytes,19,opt,name=child_tags" json:"child_tags,omitempty"`
	// The reference_points defined by this TagSpec instance determine how
	// specific child tags are identified. Please see the comment for the
	// ReferencePoint message.
	ReferencePoints []*ReferencePoint `protobuf:"bytes,20,rep,name=reference_points" json:"reference_points,omitempty"`
	// If provided, a URL which linking to a section / sentence in the
	// AMP HTML spec.
	SpecUrl *string `protobuf:"bytes,10,opt,name=spec_url" json:"spec_url,omitempty"`
	// If set, specifies which AMP Layouts are supported by this element.
	AmpLayout        *AmpLayout                `protobuf:"bytes,11,opt,name=amp_layout" json:"amp_layout,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *TagSpec) Reset()         { *m = TagSpec{} }
func (m *TagSpec) String() string { return proto.CompactTextString(m) }
func (*TagSpec) ProtoMessage()    {}

var extRange_TagSpec = []proto.ExtensionRange{
	{14, 14},
	{26, 26},
}

func (*TagSpec) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_TagSpec
}
func (m *TagSpec) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *TagSpec) GetHtmlFormat() []TagSpec_HtmlFormat {
	if m != nil {
		return m.HtmlFormat
	}
	return nil
}

func (m *TagSpec) GetTagName() string {
	if m != nil && m.TagName != nil {
		return *m.TagName
	}
	return ""
}

func (m *TagSpec) GetSpecName() string {
	if m != nil && m.SpecName != nil {
		return *m.SpecName
	}
	return ""
}

func (m *TagSpec) GetExtensionSpec() *ExtensionSpec {
	if m != nil {
		return m.ExtensionSpec
	}
	return nil
}

func (m *TagSpec) GetMandatory() bool {
	if m != nil && m.Mandatory != nil {
		return *m.Mandatory
	}
	return false
}

func (m *TagSpec) GetMandatoryAlternatives() string {
	if m != nil && m.MandatoryAlternatives != nil {
		return *m.MandatoryAlternatives
	}
	return ""
}

func (m *TagSpec) GetUnique() bool {
	if m != nil && m.Unique != nil {
		return *m.Unique
	}
	return false
}

func (m *TagSpec) GetUniqueWarning() bool {
	if m != nil && m.UniqueWarning != nil {
		return *m.UniqueWarning
	}
	return false
}

func (m *TagSpec) GetMandatoryParent() string {
	if m != nil && m.MandatoryParent != nil {
		return *m.MandatoryParent
	}
	return ""
}

func (m *TagSpec) GetMandatoryAncestor() string {
	if m != nil && m.MandatoryAncestor != nil {
		return *m.MandatoryAncestor
	}
	return ""
}

func (m *TagSpec) GetMandatoryAncestorSuggestedAlternative() string {
	if m != nil && m.MandatoryAncestorSuggestedAlternative != nil {
		return *m.MandatoryAncestorSuggestedAlternative
	}
	return ""
}

func (m *TagSpec) GetDisallowedAncestor() []string {
	if m != nil {
		return m.DisallowedAncestor
	}
	return nil
}

func (m *TagSpec) GetAlsoRequiresTagWarning() []string {
	if m != nil {
		return m.AlsoRequiresTagWarning
	}
	return nil
}

func (m *TagSpec) GetSatisfies() []string {
	if m != nil {
		return m.Satisfies
	}
	return nil
}

func (m *TagSpec) GetRequires() []string {
	if m != nil {
		return m.Requires
	}
	return nil
}

func (m *TagSpec) GetDeprecation() string {
	if m != nil && m.Deprecation != nil {
		return *m.Deprecation
	}
	return ""
}

func (m *TagSpec) GetDeprecationUrl() string {
	if m != nil && m.DeprecationUrl != nil {
		return *m.DeprecationUrl
	}
	return ""
}

func (m *TagSpec) GetAttrs() []*AttrSpec {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *TagSpec) GetAttrLists() []string {
	if m != nil {
		return m.AttrLists
	}
	return nil
}

func (m *TagSpec) GetCdata() *CdataSpec {
	if m != nil {
		return m.Cdata
	}
	return nil
}

func (m *TagSpec) GetChildTags() *ChildTagSpec {
	if m != nil {
		return m.ChildTags
	}
	return nil
}

func (m *TagSpec) GetReferencePoints() []*ReferencePoint {
	if m != nil {
		return m.ReferencePoints
	}
	return nil
}

func (m *TagSpec) GetSpecUrl() string {
	if m != nil && m.SpecUrl != nil {
		return *m.SpecUrl
	}
	return ""
}

func (m *TagSpec) GetAmpLayout() *AmpLayout {
	if m != nil {
		return m.AmpLayout
	}
	return nil
}

// Top level message - start reading here.
// The validator knows about a set of tag specifications.
// NEXT AVAILABLE TAG: 16
type ValidatorRules struct {
	Tags      []*TagSpec  `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
	AttrLists []*AttrList `protobuf:"bytes,7,rep,name=attr_lists" json:"attr_lists,omitempty"`
	// The min file revision for validator.cc which can digest this file.
	MinValidatorRevisionRequired *int32 `protobuf:"varint,4,opt,name=min_validator_revision_required" json:"min_validator_revision_required,omitempty"`
	// See comment in validator.protoascii.
	SpecFileRevision *int32 `protobuf:"varint,6,opt,name=spec_file_revision,def=-1" json:"spec_file_revision,omitempty"`
	// Spec URL for information about mustache templates.
	TemplateSpecUrl *string `protobuf:"bytes,8,opt,name=template_spec_url" json:"template_spec_url,omitempty"`
	// Spec URL for information about styles and amp-custom stylesheet
	StylesSpecUrl    *string                   `protobuf:"bytes,15,opt,name=styles_spec_url" json:"styles_spec_url,omitempty"`
	ErrorFormats     []*ErrorFormat            `protobuf:"bytes,9,rep,name=error_formats" json:"error_formats,omitempty"`
	ErrorSpecificity []*ErrorSpecificity       `protobuf:"bytes,13,rep,name=error_specificity" json:"error_specificity,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *ValidatorRules) Reset()         { *m = ValidatorRules{} }
func (m *ValidatorRules) String() string { return proto.CompactTextString(m) }
func (*ValidatorRules) ProtoMessage()    {}

var extRange_ValidatorRules = []proto.ExtensionRange{
	{2, 2},
	{5, 5},
	{11, 11},
	{12, 12},
	{14, 14},
}

func (*ValidatorRules) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_ValidatorRules
}
func (m *ValidatorRules) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

const Default_ValidatorRules_SpecFileRevision int32 = -1

func (m *ValidatorRules) GetTags() []*TagSpec {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ValidatorRules) GetAttrLists() []*AttrList {
	if m != nil {
		return m.AttrLists
	}
	return nil
}

func (m *ValidatorRules) GetMinValidatorRevisionRequired() int32 {
	if m != nil && m.MinValidatorRevisionRequired != nil {
		return *m.MinValidatorRevisionRequired
	}
	return 0
}

func (m *ValidatorRules) GetSpecFileRevision() int32 {
	if m != nil && m.SpecFileRevision != nil {
		return *m.SpecFileRevision
	}
	return Default_ValidatorRules_SpecFileRevision
}

func (m *ValidatorRules) GetTemplateSpecUrl() string {
	if m != nil && m.TemplateSpecUrl != nil {
		return *m.TemplateSpecUrl
	}
	return ""
}

func (m *ValidatorRules) GetStylesSpecUrl() string {
	if m != nil && m.StylesSpecUrl != nil {
		return *m.StylesSpecUrl
	}
	return ""
}

func (m *ValidatorRules) GetErrorFormats() []*ErrorFormat {
	if m != nil {
		return m.ErrorFormats
	}
	return nil
}

func (m *ValidatorRules) GetErrorSpecificity() []*ErrorSpecificity {
	if m != nil {
		return m.ErrorSpecificity
	}
	return nil
}

// We categorize error messages into higher-level groups. This makes it
// easier to create error statistics across a site and give advice based
// on the most common problems for a set of pages.
type ErrorCategory struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *ErrorCategory) Reset()         { *m = ErrorCategory{} }
func (m *ErrorCategory) String() string { return proto.CompactTextString(m) }
func (*ErrorCategory) ProtoMessage()    {}

type ValidationError struct {
	Severity *ValidationError_Severity `protobuf:"varint,6,opt,name=severity,enum=amp.validator.ValidationError_Severity,def=1" json:"severity,omitempty"`
	Code     *ValidationError_Code     `protobuf:"varint,1,opt,name=code,enum=amp.validator.ValidationError_Code" json:"code,omitempty"`
	Line     *int32                    `protobuf:"varint,2,opt,name=line,def=1" json:"line,omitempty"`
	Col      *int32                    `protobuf:"varint,3,opt,name=col" json:"col,omitempty"`
	Detail   *string                   `protobuf:"bytes,4,opt,name=detail" json:"detail,omitempty"`
	SpecUrl  *string                   `protobuf:"bytes,5,opt,name=spec_url" json:"spec_url,omitempty"`
	Params   []string                  `protobuf:"bytes,7,rep,name=params" json:"params,omitempty"`
	// This field is not populated by default. See
	// amp.validator.categorizeError and
	// amp.validator.annotateWithErrorCategories if you need this.
	Category *ErrorCategory_Code `protobuf:"varint,8,opt,name=category,enum=amp.validator.ErrorCategory_Code" json:"category,omitempty"`
	// Used only in JavaScript, if an error is emitted for a specific HTML tag and
	// if that HTML tag has an attribute named data-amp-report-test, this string
	// will be set and contain the value found for that attribute. This is used
	// in tests to match specific errors to specific tags in the test cases. It
	// is not a rendered value.
	DataAmpReportTestValue *string `protobuf:"bytes,9,opt,name=data_amp_report_test_value" json:"data_amp_report_test_value,omitempty"`
	XXX_unrecognized       []byte  `json:"-"`
}

func (m *ValidationError) Reset()         { *m = ValidationError{} }
func (m *ValidationError) String() string { return proto.CompactTextString(m) }
func (*ValidationError) ProtoMessage()    {}

const Default_ValidationError_Severity ValidationError_Severity = ValidationError_ERROR
const Default_ValidationError_Line int32 = 1

func (m *ValidationError) GetSeverity() ValidationError_Severity {
	if m != nil && m.Severity != nil {
		return *m.Severity
	}
	return Default_ValidationError_Severity
}

func (m *ValidationError) GetCode() ValidationError_Code {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ValidationError_UNKNOWN_CODE
}

func (m *ValidationError) GetLine() int32 {
	if m != nil && m.Line != nil {
		return *m.Line
	}
	return Default_ValidationError_Line
}

func (m *ValidationError) GetCol() int32 {
	if m != nil && m.Col != nil {
		return *m.Col
	}
	return 0
}

func (m *ValidationError) GetDetail() string {
	if m != nil && m.Detail != nil {
		return *m.Detail
	}
	return ""
}

func (m *ValidationError) GetSpecUrl() string {
	if m != nil && m.SpecUrl != nil {
		return *m.SpecUrl
	}
	return ""
}

func (m *ValidationError) GetParams() []string {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *ValidationError) GetCategory() ErrorCategory_Code {
	if m != nil && m.Category != nil {
		return *m.Category
	}
	return ErrorCategory_UNKNOWN
}

func (m *ValidationError) GetDataAmpReportTestValue() string {
	if m != nil && m.DataAmpReportTestValue != nil {
		return *m.DataAmpReportTestValue
	}
	return ""
}

// Used in the verbose validator to select between multiple generated error
// types for a failing error. A higher number means that the error is more
// specific, ie: more helpful, preferred.
type ErrorSpecificity struct {
	Code             *ValidationError_Code `protobuf:"varint,1,opt,name=code,enum=amp.validator.ValidationError_Code" json:"code,omitempty"`
	Specificity      *int32                `protobuf:"varint,2,opt,name=specificity" json:"specificity,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *ErrorSpecificity) Reset()         { *m = ErrorSpecificity{} }
func (m *ErrorSpecificity) String() string { return proto.CompactTextString(m) }
func (*ErrorSpecificity) ProtoMessage()    {}

func (m *ErrorSpecificity) GetCode() ValidationError_Code {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ValidationError_UNKNOWN_CODE
}

func (m *ErrorSpecificity) GetSpecificity() int32 {
	if m != nil && m.Specificity != nil {
		return *m.Specificity
	}
	return 0
}

type ErrorFormat struct {
	Code             *ValidationError_Code `protobuf:"varint,1,opt,name=code,enum=amp.validator.ValidationError_Code" json:"code,omitempty"`
	Format           *string               `protobuf:"bytes,2,opt,name=format" json:"format,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *ErrorFormat) Reset()         { *m = ErrorFormat{} }
func (m *ErrorFormat) String() string { return proto.CompactTextString(m) }
func (*ErrorFormat) ProtoMessage()    {}

func (m *ErrorFormat) GetCode() ValidationError_Code {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ValidationError_UNKNOWN_CODE
}

func (m *ErrorFormat) GetFormat() string {
	if m != nil && m.Format != nil {
		return *m.Format
	}
	return ""
}

// The validation result provided by Validator instances (see Validator::Result
// in validator.h). To render such a proto see RenderValidationResult.
type ValidationResult struct {
	Status            *ValidationResult_Status `protobuf:"varint,2,opt,name=status,enum=amp.validator.ValidationResult_Status" json:"status,omitempty"`
	Errors            []*ValidationError       `protobuf:"bytes,1,rep,name=errors" json:"errors,omitempty"`
	ValidatorRevision *int32                   `protobuf:"varint,3,opt,name=validator_revision,def=-1" json:"validator_revision,omitempty"`
	SpecFileRevision  *int32                   `protobuf:"varint,4,opt,name=spec_file_revision,def=-1" json:"spec_file_revision,omitempty"`
	XXX_unrecognized  []byte                   `json:"-"`
}

func (m *ValidationResult) Reset()         { *m = ValidationResult{} }
func (m *ValidationResult) String() string { return proto.CompactTextString(m) }
func (*ValidationResult) ProtoMessage()    {}

const Default_ValidationResult_ValidatorRevision int32 = -1
const Default_ValidationResult_SpecFileRevision int32 = -1

func (m *ValidationResult) GetStatus() ValidationResult_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ValidationResult_UNKNOWN
}

func (m *ValidationResult) GetErrors() []*ValidationError {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *ValidationResult) GetValidatorRevision() int32 {
	if m != nil && m.ValidatorRevision != nil {
		return *m.ValidatorRevision
	}
	return Default_ValidationResult_ValidatorRevision
}

func (m *ValidationResult) GetSpecFileRevision() int32 {
	if m != nil && m.SpecFileRevision != nil {
		return *m.SpecFileRevision
	}
	return Default_ValidationResult_SpecFileRevision
}

// Information about the validator returned by ValidatorFactory
// (see validator.h).
type ValidatorInfo struct {
	// Path from which the spec file was loaded.
	RulesPath *string `protobuf:"bytes,1,opt,name=rules_path" json:"rules_path,omitempty"`
	// The file revision of validator.cc.
	ValidatorRevision *int32 `protobuf:"varint,2,opt,name=validator_revision,def=-1" json:"validator_revision,omitempty"`
	// The file revision of the spec file (validator.protoascii).
	SpecFileRevision *int32 `protobuf:"varint,3,opt,name=spec_file_revision,def=-1" json:"spec_file_revision,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ValidatorInfo) Reset()         { *m = ValidatorInfo{} }
func (m *ValidatorInfo) String() string { return proto.CompactTextString(m) }
func (*ValidatorInfo) ProtoMessage()    {}

const Default_ValidatorInfo_ValidatorRevision int32 = -1
const Default_ValidatorInfo_SpecFileRevision int32 = -1

func (m *ValidatorInfo) GetRulesPath() string {
	if m != nil && m.RulesPath != nil {
		return *m.RulesPath
	}
	return ""
}

func (m *ValidatorInfo) GetValidatorRevision() int32 {
	if m != nil && m.ValidatorRevision != nil {
		return *m.ValidatorRevision
	}
	return Default_ValidatorInfo_ValidatorRevision
}

func (m *ValidatorInfo) GetSpecFileRevision() int32 {
	if m != nil && m.SpecFileRevision != nil {
		return *m.SpecFileRevision
	}
	return Default_ValidatorInfo_SpecFileRevision
}

func init() {
	proto.RegisterEnum("amp.validator.AtRuleSpec_BlockType", AtRuleSpec_BlockType_name, AtRuleSpec_BlockType_value)
	proto.RegisterEnum("amp.validator.AmpLayout_Layout", AmpLayout_Layout_name, AmpLayout_Layout_value)
	proto.RegisterEnum("amp.validator.TagSpec_HtmlFormat", TagSpec_HtmlFormat_name, TagSpec_HtmlFormat_value)
	proto.RegisterEnum("amp.validator.ErrorCategory_Code", ErrorCategory_Code_name, ErrorCategory_Code_value)
	proto.RegisterEnum("amp.validator.ValidationError_Severity", ValidationError_Severity_name, ValidationError_Severity_value)
	proto.RegisterEnum("amp.validator.ValidationError_Code", ValidationError_Code_name, ValidationError_Code_value)
	proto.RegisterEnum("amp.validator.ValidationResult_Status", ValidationResult_Status_name, ValidationResult_Status_value)
}
